<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a1a1a">
    <link rel="manifest" href="manifest.json">
    <title>Detector Billetes Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            min-height: 100vh;
            padding: 10px;
        }

        .header {
            text-align: center;
            padding: 12px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .header h1 {
            font-size: 20px;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status {
            font-size: 12px;
            color: #888;
        }

        .camera-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            margin: 0 auto 10px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
            background: #000;
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }

        .btn-switch-camera {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
        }

        .total-display {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .total-display h2 {
            font-size: 36px;
            color: #000;
            font-weight: bold;
            margin: 0;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }

        .control-row input[type="range"] {
            flex: 1;
            min-width: 100px;
        }

        .control-row span {
            color: #00ff88;
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            font-size: 12px;
        }

        .desglose {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            min-height: 70px;
            max-height: 150px;
            overflow-y: auto;
        }

        .desglose-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
        }

        .desglose-item:last-child {
            border-bottom: none;
        }

        .historial {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .historial h3 {
            margin-bottom: 8px;
            font-size: 15px;
        }

        .historial-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }

        .btn-clear {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }

        .btn-start {
            background: linear-gradient(135deg, #00ccff, #0088ff);
            color: #fff;
            grid-column: 1 / -1;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: rgba(255, 68, 68, 0.2);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin: 8px 0;
            text-align: center;
            font-size: 12px;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 18px;
            }
            
            .total-display h2 {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ’µ Detector de Billetes Pro</h1>
            <div class="status" id="status">Presiona iniciar</div>
        </div>

        <div class="camera-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <div class="camera-controls">
                <button class="btn-switch-camera" id="btnSwitchCamera" onclick="cambiarCamara()" style="display:none;">
                    ğŸ”„
                </button>
            </div>
        </div>

        <div class="total-display">
            <h2 id="total">$0</h2>
        </div>

        <div class="controls-panel">
            <div class="control-row">
                <label>Confianza:</label>
                <input type="range" id="confSlider" min="20" max="90" value="50" oninput="actualizarConf(this.value)">
                <span id="confValue">50%</span>
            </div>
            <div class="control-row">
                <label>Velocidad:</label>
                <input type="range" id="speedSlider" min="1" max="5" value="2" oninput="actualizarVelocidad(this.value)">
                <span id="speedValue">Media</span>
            </div>
        </div>

        <div class="desglose" id="desglose">
            <p style="text-align: center; color: #888; font-size: 13px;">Sin detecciones</p>
        </div>

        <div class="historial">
            <h3>ğŸ“‹ Historial</h3>
            <div id="historial-list"></div>
        </div>

        <div class="buttons">
            <button class="btn-start" id="btnStart" onclick="iniciarCamara()">
                ğŸ¥ INICIAR CÃMARA
            </button>
            <button class="btn-start" style="background: linear-gradient(135deg, #ff9500, #ff5e00);" onclick="probarConImagen()">
                ğŸ–¼ï¸ PROBAR CON IMAGEN
            </button>
            <button class="btn-save" onclick="guardarConteo()">ğŸ’¾ GUARDAR</button>
            <button class="btn-clear" onclick="limpiarTodo()">ğŸ—‘ï¸ LIMPIAR</button>
        </div>

        <!-- Input oculto para cargar imagen -->
        <input type="file" id="imageInput" accept="image/*" style="display:none;" onchange="procesarImagen(this)">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <script>
        // âš ï¸ ORDEN EXACTO DEL YAML - NO CAMBIAR
        const CLASS_NAMES = ['100', '1000', '10000', '100000', '200', '2000', '20000', '50', '500', '5000', '50000'];
        
        const VALORES = {
            "100": 100,
            "1000": 1000,
            "10000": 10000,
            "100000": 100000,
            "200": 200,
            "2000": 2000,
            "20000": 20000,
            "50": 50,
            "500": 500,
            "5000": 5000,
            "50000": 50000
        };

        let CONF_THRESHOLD = 0.5;  // Reducido de 0.6 a 0.5 (50%)
        const IOU_THRESHOLD = 0.5;  // Reducido para evitar suprimir detecciones vÃ¡lidas
        const INPUT_SIZE = 640;  // Debe coincidir con tu entrenamiento

        let video, canvas, ctx;
        let stream = null;
        let deteccionesActuales = {};
        let totalActual = 0;
        let historial = [];
        let deteccionActiva = false;
        let session = null;
        let camarasDisponibles = [];
        let camaraActualIndex = 0;
        let deteccionInterval = 2000;
        let procesando = false;

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .catch(err => console.log('SW error:', err));
        }

        function actualizarConf(value) {
            CONF_THRESHOLD = value / 100;
            document.getElementById('confValue').textContent = value + '%';
        }

        function actualizarVelocidad(value) {
            const velocidades = {
                '1': { texto: 'Lenta', ms: 3000 },
                '2': { texto: 'Media', ms: 2000 },
                '3': { texto: 'RÃ¡pida', ms: 1500 },
                '4': { texto: 'Turbo', ms: 1000 },
                '5': { texto: 'Ultra', ms: 500 }
            };
            const vel = velocidades[value];
            deteccionInterval = vel.ms;
            document.getElementById('speedValue').textContent = vel.texto;
        }

        function cargarHistorial() {
            const saved = localStorage.getItem('historial_billetes');
            if (saved) {
                historial = JSON.parse(saved);
                actualizarHistorialUI();
            }
        }

        window.onload = async function() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            cargarHistorial();
            
            // ğŸ” Detectar navegadores problemÃ¡ticos
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            let navegadorProblematico = false;
            let mensajeNavegador = '';
            
            // Detectar navegadores in-app
            if (/FBAN|FBAV|Instagram|Line|Snapchat|Twitter|WhatsApp/i.test(userAgent)) {
                navegadorProblematico = true;
                mensajeNavegador = 'âš ï¸ Navegador in-app detectado. Abre en Chrome/Safari';
            }
            
            // Detectar iOS + no Safari
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
            
            if (isIOS && !isSafari) {
                navegadorProblematico = true;
                mensajeNavegador = 'âš ï¸ En iOS usa Safari. Chrome/Firefox no tienen acceso a cÃ¡mara';
            }
            
            if (navegadorProblematico) {
                document.getElementById('status').innerHTML = 
                    `<div class="error">${mensajeNavegador}<br><small>ğŸ’¡ Usa "PROBAR CON IMAGEN" como alternativa</small></div>`;
                console.warn('âš ï¸', mensajeNavegador);
            }
            
            try {
                document.getElementById('status').textContent = navegadorProblematico ? 
                    mensajeNavegador : 'Cargando modelo...';
                console.log('ğŸ”„ Intentando cargar: models/best.onnx');
                
                session = await ort.InferenceSession.create('models/best.onnx');
                
                // ğŸ” DIAGNOSTICO COMPLETO DEL MODELO
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ… MODELO CARGADO EXITOSAMENTE');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ğŸ“¥ Input name:', session.inputNames[0]);
                console.log('ğŸ“¤ Output name:', session.outputNames[0]);
                console.log('ğŸ¯ Clases configuradas:', CLASS_NAMES.length);
                console.log('ğŸ“‹ Lista de clases:', CLASS_NAMES);
                console.log('ğŸ’° Valores:', VALORES);
                console.log('ğŸŒ User Agent:', userAgent);
                console.log('ğŸ“± iOS:', isIOS, '| Safari:', isSafari);
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                if (!navegadorProblematico) {
                    document.getElementById('status').textContent = 'âœ… Listo - Presiona INICIAR';
                }
            } catch (error) {
                console.error('âŒ ERROR CARGANDO MODELO:', error);
                console.log('ğŸ“ Verifica que existe: models/best.onnx');
                console.log('ğŸŒ Ruta completa deberÃ­a ser:', window.location.origin + '/models/best.onnx');
                document.getElementById('status').innerHTML = 
                    '<div class="error">âš ï¸ Modelo no encontrado en /models/best.onnx</div>';
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                camarasDisponibles = devices.filter(d => d.kind === 'videoinput');
                console.log('CÃ¡maras:', camarasDisponibles.length);
                
                if (camarasDisponibles.length > 1) {
                    document.getElementById('btnSwitchCamera').style.display = 'block';
                }
            } catch (error) {
                console.error('Error listando cÃ¡maras:', error);
            }
        };

        async function iniciarCamara() {
            if (!session) {
                alert('âš ï¸ Modelo no cargado');
                return;
            }

            // Verificar si estamos en HTTPS
            const esHTTPS = window.location.protocol === 'https:';
            const esLocalhost = window.location.hostname === 'localhost' || 
                               window.location.hostname === '127.0.0.1';
            
            if (!esHTTPS && !esLocalhost) {
                document.getElementById('status').innerHTML = 
                    '<div class="error">âš ï¸ HTTPS requerido para cÃ¡mara. Usa el botÃ³n "PROBAR CON IMAGEN"</div>';
                console.error('âŒ Acceso a cÃ¡mara bloqueado: se requiere HTTPS');
                console.log('ğŸ“ URL actual:', window.location.href);
                console.log('ğŸ’¡ SoluciÃ³n: Accede via HTTPS o usa localhost');
                return;
            }

            try {
                document.getElementById('status').textContent = 'â³ Solicitando permisos de cÃ¡mara...';
                document.getElementById('btnStart').disabled = true;
                
                console.log('ğŸ”„ Iniciando solicitud de cÃ¡mara...');
                console.log('ğŸ“ Protocolo:', window.location.protocol);
                console.log('ğŸ“ Host:', window.location.hostname);

                // Verificar disponibilidad de getUserMedia
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Tu navegador no soporta acceso a la cÃ¡mara');
                }

                let constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'environment'  // CÃ¡mara trasera en mÃ³viles
                    }
                };

                // Si hay cÃ¡maras disponibles, INTENTAR usar la seleccionada (pero no forzar con 'exact')
                if (camarasDisponibles.length > 0) {
                    const camara = camarasDisponibles[camaraActualIndex];
                    // Usar 'ideal' en lugar de 'exact' para ser mÃ¡s flexible
                    constraints.video.deviceId = { ideal: camara.deviceId };
                    console.log('ğŸ“¹ Intentando usar:', camara.label || `CÃ¡mara ${camaraActualIndex + 1}`);
                }

                console.log('ğŸ¥ Solicitando acceso con constraints:', constraints);
                
                // Timeout de 10 segundos
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout: Sin respuesta del usuario')), 10000)
                );
                
                // Intentar primero con constraints ideales
                try {
                    stream = await Promise.race([
                        navigator.mediaDevices.getUserMedia(constraints),
                        timeoutPromise
                    ]);
                    console.log('âœ… Stream obtenido con constraints ideales');
                } catch (constraintError) {
                    // Si falla, intentar con constraints mÃ­nimas (fallback)
                    if (constraintError.name === 'OverconstrainedError') {
                        console.warn('âš ï¸ Constraints muy altas, intentando modo bÃ¡sico...');
                        
                        const basicConstraints = {
                            video: {
                                facingMode: 'environment'
                                // Sin restricciones de resoluciÃ³n
                            }
                        };
                        
                        stream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                        console.log('âœ… Stream obtenido con constraints bÃ¡sicas');
                    } else {
                        throw constraintError; // Re-lanzar si es otro error
                    }
                }
                
                console.log('âœ… Stream obtenido');
                video.srcObject = stream;
                
                video.onloadedmetadata = function() {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    console.log('âœ… CÃ¡mara iniciada:', video.videoWidth, 'x', video.videoHeight);
                    
                    document.getElementById('status').textContent = 'âœ… Detectando';
                    document.getElementById('btnStart').textContent = 'ğŸ›‘ DETENER';
                    document.getElementById('btnStart').onclick = detenerCamara;
                    document.getElementById('btnStart').disabled = false;
                    
                    deteccionActiva = true;
                    detectarConONNX();
                };

            } catch (error) {
                console.error('âŒ Error de cÃ¡mara:', error);
                
                let mensaje = 'âŒ ';
                let sugerencia = '';
                
                if (error.message === 'Timeout: Sin respuesta del usuario') {
                    mensaje += 'No se recibiÃ³ respuesta. Â¿Denegaste el permiso?';
                    sugerencia = 'ğŸ’¡ Recarga la pÃ¡gina e intenta de nuevo';
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    mensaje += 'Permisos de cÃ¡mara denegados';
                    sugerencia = 'ğŸ’¡ Ve a configuraciÃ³n del navegador y permite el acceso a la cÃ¡mara';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    mensaje += 'No se encontrÃ³ ninguna cÃ¡mara';
                    sugerencia = 'ğŸ’¡ Usa el botÃ³n "ğŸ–¼ï¸ PROBAR CON IMAGEN"';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    mensaje += 'CÃ¡mara ocupada por otra aplicaciÃ³n';
                    sugerencia = 'ğŸ’¡ Cierra otras apps que usen la cÃ¡mara';
                } else if (error.name === 'OverconstrainedError') {
                    mensaje += 'No hay cÃ¡mara compatible';
                    sugerencia = 'ğŸ’¡ Usa el botÃ³n "ğŸ–¼ï¸ PROBAR CON IMAGEN"';
                } else if (error.name === 'TypeError') {
                    mensaje += 'Navegador no compatible';
                    sugerencia = 'ğŸ’¡ Intenta con Chrome o Firefox';
                } else {
                    mensaje += error.message;
                    sugerencia = 'ğŸ’¡ Usa el botÃ³n "ğŸ–¼ï¸ PROBAR CON IMAGEN"';
                }
                
                document.getElementById('status').innerHTML = 
                    `<div class="error">${mensaje}<br><small>${sugerencia}</small></div>`;
                document.getElementById('btnStart').disabled = false;
                
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âŒ DIAGNÃ“STICO DE ERROR');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('Error:', error.name);
                console.log('Mensaje:', error.message);
                console.log('HTTPS:', esHTTPS);
                console.log('Localhost:', esLocalhost);
                console.log('UserAgent:', navigator.userAgent);
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            }
        }

        async function cambiarCamara() {
            if (camarasDisponibles.length <= 1) return;
            camaraActualIndex = (camaraActualIndex + 1) % camarasDisponibles.length;
            if (stream) {
                detenerCamara();
                setTimeout(() => iniciarCamara(), 300);
            }
        }

        function detenerCamara() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                deteccionActiva = false;
                procesando = false;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                document.getElementById('status').textContent = 'â¸ï¸ Detenido';
                document.getElementById('btnStart').textContent = 'ğŸ¥ INICIAR';
                document.getElementById('btnStart').onclick = iniciarCamara;
            }
        }

        async function detectarConONNX() {
            if (!deteccionActiva || !session || procesando) {
                if (deteccionActiva) {
                    setTimeout(detectarConONNX, deteccionInterval);
                }
                return;
            }

            procesando = true;

            try {
                const input = preprocesarImagen();
                const feeds = {};
                feeds[session.inputNames[0]] = input;
                const results = await session.run(feeds);
                
                const output = results[session.outputNames[0]];
                const outputData = output.data;
                
                // ğŸ” DIAGNOSTICO (solo primera vez)
                if (!window.diagnosticoDone) {
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('ğŸ” DIAGNÃ“STICO DEL MODELO ONNX');
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('ğŸ“Š Shape output:', output.dims);
                    console.log('ğŸ“ Total elementos:', outputData.length);
                    console.log('ğŸ¯ Clases esperadas:', CLASS_NAMES.length);
                    console.log('ğŸ“ Input size:', INPUT_SIZE);
                    
                    // Calcular formato
                    const numClases = CLASS_NAMES.length;
                    const numPreds = Math.floor(outputData.length / (4 + numClases));
                    console.log('ğŸ”¢ Predicciones calculadas:', numPreds);
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    
                    window.diagnosticoDone = true;
                }
                
                const detecciones = postprocesarResultados(outputData, canvas.width, canvas.height);
                const deteccionesFiltradas = nonMaxSuppression(detecciones, IOU_THRESHOLD);
                
                deteccionesActuales = {};
                for (const det of deteccionesFiltradas) {
                    deteccionesActuales[det.class] = (deteccionesActuales[det.class] || 0) + 1;
                }
                
                actualizarDisplay();
                dibujarDetecciones(deteccionesFiltradas);
                
            } catch (error) {
                console.error('Error detecciÃ³n:', error);
            }

            procesando = false;
            setTimeout(detectarConONNX, deteccionInterval);
        }

        function preprocesarImagen() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = INPUT_SIZE;
            tempCanvas.height = INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
            const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            const { data } = imageData;
            
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            
            for (let i = 0; i < INPUT_SIZE * INPUT_SIZE; i++) {
                input[i] = data[i * 4] / 255.0;
                input[INPUT_SIZE * INPUT_SIZE + i] = data[i * 4 + 1] / 255.0;
                input[INPUT_SIZE * INPUT_SIZE * 2 + i] = data[i * 4 + 2] / 255.0;
            }
            
            return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
        }

        function postprocesarResultados(outputData, imgWidth, imgHeight) {
            const detecciones = [];
            const numClases = CLASS_NAMES.length;
            
            // YOLOv11 ONNX formato: [1, 4+nc, num_predictions]
            // Calcular nÃºmero de predicciones
            const totalElements = outputData.length;
            const numPredictions = Math.floor(totalElements / (4 + numClases));
            
            console.log('ğŸ” DEBUG:', {
                totalElements,
                numClases,
                numPredictions,
                expectedSize: (4 + numClases) * numPredictions
            });
            
            for (let i = 0; i < numPredictions; i++) {
                // YOLOv11: las coordenadas estÃ¡n en las primeras 4 filas
                // outputData estÃ¡ organizado como: [x0, x1, x2, ..., y0, y1, y2, ..., w0, w1, ...]
                const xCenter = outputData[i];                          // Fila 0
                const yCenter = outputData[numPredictions + i];         // Fila 1
                const width = outputData[numPredictions * 2 + i];       // Fila 2
                const height = outputData[numPredictions * 3 + i];      // Fila 3
                
                // Las probabilidades de clase empiezan en la fila 4
                let maxScore = 0;
                let maxClassId = 0;
                
                for (let c = 0; c < numClases; c++) {
                    const scoreIndex = numPredictions * (4 + c) + i;
                    const score = outputData[scoreIndex];
                    
                    if (score > maxScore) {
                        maxScore = score;
                        maxClassId = c;
                    }
                }
                
                // Filtrar por confianza
                if (maxScore > CONF_THRESHOLD) {
                    // YOLOv11 devuelve coordenadas normalizadas (0-1) relativas a INPUT_SIZE
                    // Convertir a pÃ­xeles del canvas
                    const x1 = Math.max(0, (xCenter - width / 2) * imgWidth / INPUT_SIZE);
                    const y1 = Math.max(0, (yCenter - height / 2) * imgHeight / INPUT_SIZE);
                    const x2 = Math.min(imgWidth, (xCenter + width / 2) * imgWidth / INPUT_SIZE);
                    const y2 = Math.min(imgHeight, (yCenter + height / 2) * imgHeight / INPUT_SIZE);
                    
                    detecciones.push({
                        class: CLASS_NAMES[maxClassId],
                        conf: maxScore,
                        bbox: [x1, y1, x2, y2]
                    });
                    
                    console.log(`âœ… ${CLASS_NAMES[maxClassId]}: ${(maxScore*100).toFixed(1)}%`);
                }
            }
            
            console.log(`ğŸ“Š Detecciones vÃ¡lidas: ${detecciones.length}/${numPredictions}`);
            return detecciones;
        }

        function nonMaxSuppression(detecciones, iouThreshold) {
            detecciones.sort((a, b) => b.conf - a.conf);
            const resultado = [];
            const suppressed = new Array(detecciones.length).fill(false);
            
            for (let i = 0; i < detecciones.length; i++) {
                if (suppressed[i]) continue;
                resultado.push(detecciones[i]);
                
                for (let j = i + 1; j < detecciones.length; j++) {
                    if (suppressed[j]) continue;
                    if (detecciones[i].class === detecciones[j].class) {
                        const iou = calcularIoU(detecciones[i].bbox, detecciones[j].bbox);
                        if (iou > iouThreshold) suppressed[j] = true;
                    }
                }
            }
            
            return resultado;
        }

        function calcularIoU(bbox1, bbox2) {
            const [x1_1, y1_1, x2_1, y2_1] = bbox1;
            const [x1_2, y1_2, x2_2, y2_2] = bbox2;
            
            const xi1 = Math.max(x1_1, x1_2);
            const yi1 = Math.max(y1_1, y1_2);
            const xi2 = Math.min(x2_1, x2_2);
            const yi2 = Math.min(y2_1, y2_2);
            
            const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
            const bbox1Area = (x2_1 - x1_1) * (y2_1 - y1_1);
            const bbox2Area = (x2_2 - x1_2) * (y2_2 - y1_2);
            const unionArea = bbox1Area + bbox2Area - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        function dibujarDetecciones(detecciones) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            
            for (const det of detecciones) {
                const [x1, y1, x2, y2] = det.bbox;
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                
                const label = `${det.class} ${(det.conf * 100).toFixed(0)}%`;
                const textWidth = ctx.measureText(label).width;
                
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(x1, y1 - 20, textWidth + 8, 20);
                ctx.fillStyle = '#000';
                ctx.fillText(label, x1 + 4, y1 - 4);
            }
        }

        function actualizarDisplay() {
            totalActual = 0;
            for (let [billete, cantidad] of Object.entries(deteccionesActuales)) {
                totalActual += VALORES[billete] * cantidad;
            }

            document.getElementById('total').textContent = `$${totalActual.toLocaleString()}`;

            const desgloseDiv = document.getElementById('desglose');
            if (Object.keys(deteccionesActuales).length === 0) {
                desgloseDiv.innerHTML = '<p style="text-align:center;color:#888;font-size:13px;">Sin detecciones</p>';
            } else {
                let html = '';
                for (let [billete, cantidad] of Object.entries(deteccionesActuales)) {
                    const subtotal = VALORES[billete] * cantidad;
                    html += `
                        <div class="desglose-item">
                            <span>${cantidad}x $${billete}</span>
                            <span style="color:#00ff88;font-weight:bold;">$${subtotal.toLocaleString()}</span>
                        </div>`;
                }
                desgloseDiv.innerHTML = html;
            }
        }

        function guardarConteo() {
            if (totalActual === 0) {
                alert('âš ï¸ No hay nada que guardar');
                return;
            }

            const registro = {
                timestamp: new Date().toLocaleString(),
                total: totalActual,
                desglose: {...deteccionesActuales}
            };

            historial.unshift(registro);
            if (historial.length > 50) historial = historial.slice(0, 50);
            localStorage.setItem('historial_billetes', JSON.stringify(historial));
            actualizarHistorialUI();

            document.getElementById('status').textContent = 'âœ… Guardado';
            setTimeout(() => {
                if (deteccionActiva) document.getElementById('status').textContent = 'âœ… Detectando';
            }, 1500);
        }

        function actualizarHistorialUI() {
            const list = document.getElementById('historial-list');
            if (historial.length === 0) {
                list.innerHTML = '<p style="text-align:center;color:#888;font-size:12px;">Sin registros</p>';
                return;
            }

            let html = '';
            for (let reg of historial.slice(0, 8)) {
                const desglose = Object.entries(reg.desglose).map(([b, c]) => `${c}x$${b}`).join(', ');
                html += `
                    <div class="historial-item">
                        <strong>$${reg.total.toLocaleString()}</strong><br>
                        <small>${desglose}</small><br>
                        <small style="color:#888;">${reg.timestamp}</small>
                    </div>`;
            }
            list.innerHTML = html;
        }

        function limpiarTodo() {
            if (confirm('Â¿Limpiar historial?')) {
                deteccionesActuales = {};
                totalActual = 0;
                historial = [];
                localStorage.removeItem('historial_billetes');
                actualizarDisplay();
                actualizarHistorialUI();
                document.getElementById('status').textContent = 'ğŸ—‘ï¸ Limpiado';
            }
        }

        // ğŸ–¼ï¸ FUNCIONES PARA PROBAR CON IMAGEN
        function probarConImagen() {
            if (!session) {
                alert('âš ï¸ Modelo no cargado');
                return;
            }
            document.getElementById('imageInput').click();
        }

        async function procesarImagen(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            console.log('ğŸ“¸ Procesando imagen:', file.name);
            
            const img = new Image();
            img.onload = async function() {
                // Detener cÃ¡mara si estÃ¡ activa
                if (stream) detenerCamara();
                
                // Ajustar canvas al tamaÃ±o de la imagen
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Dibujar imagen en el video (para visualizaciÃ³n)
                const videoCtx = canvas.getContext('2d');
                videoCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                try {
                    console.log('ğŸ” Iniciando detecciÃ³n en imagen...');
                    document.getElementById('status').textContent = 'ğŸ” Analizando...';
                    
                    // Preprocesar imagen
                    const input = preprocesarImagenStatic(img);
                    const feeds = {};
                    feeds[session.inputNames[0]] = input;
                    
                    // Ejecutar modelo
                    const results = await session.run(feeds);
                    const output = results[session.outputNames[0]];
                    const outputData = output.data;
                    
                    console.log('ğŸ“Š Output recibido:', output.dims, 'Elementos:', outputData.length);
                    
                    // Procesar detecciones
                    const detecciones = postprocesarResultados(outputData, canvas.width, canvas.height);
                    const deteccionesFiltradas = nonMaxSuppression(detecciones, IOU_THRESHOLD);
                    
                    console.log('âœ… Detecciones encontradas:', deteccionesFiltradas.length);
                    
                    // Actualizar display
                    deteccionesActuales = {};
                    for (const det of deteccionesFiltradas) {
                        deteccionesActuales[det.class] = (deteccionesActuales[det.class] || 0) + 1;
                    }
                    
                    actualizarDisplay();
                    dibujarDetecciones(deteccionesFiltradas);
                    
                    document.getElementById('status').textContent = 
                        deteccionesFiltradas.length > 0 ? 
                        `âœ… ${deteccionesFiltradas.length} billetes detectados` : 
                        'âš ï¸ No se detectaron billetes';
                    
                } catch (error) {
                    console.error('âŒ Error procesando imagen:', error);
                    document.getElementById('status').innerHTML = 
                        '<div class="error">âŒ Error al procesar</div>';
                }
            };
            
            img.src = URL.createObjectURL(file);
        }

        function preprocesarImagenStatic(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = INPUT_SIZE;
            tempCanvas.height = INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(img, 0, 0, INPUT_SIZE, INPUT_SIZE);
            const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            const { data } = imageData;
            
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            
            for (let i = 0; i < INPUT_SIZE * INPUT_SIZE; i++) {
                input[i] = data[i * 4] / 255.0;
                input[INPUT_SIZE * INPUT_SIZE + i] = data[i * 4 + 1] / 255.0;
                input[INPUT_SIZE * INPUT_SIZE * 2 + i] = data[i * 4 + 2] / 255.0;
            }
            
            return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
        }

        window.onbeforeunload = function() {
            if (stream) stream.getTracks().forEach(t => t.stop());
        };
    </script>
</body>
</html>