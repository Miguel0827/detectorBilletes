<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a1a1a">
    <title>Detector Billetes Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            min-height: 100vh;
            padding: 10px;
        }

        .header {
            text-align: center;
            padding: 12px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .header h1 {
            font-size: 20px;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status {
            font-size: 12px;
            color: #888;
        }

        .camera-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            margin: 0 auto 10px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
            background: #000;
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }

        .btn-switch-camera {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
        }

        .total-display {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .total-display h2 {
            font-size: 36px;
            color: #000;
            font-weight: bold;
            margin: 0;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }

        .control-row input[type="range"] {
            flex: 1;
            min-width: 100px;
        }

        .control-row span {
            color: #00ff88;
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            font-size: 12px;
        }

        .desglose {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            min-height: 70px;
            max-height: 150px;
            overflow-y: auto;
        }

        .desglose-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
        }

        .desglose-item:last-child {
            border-bottom: none;
        }

        .historial {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .historial h3 {
            margin-bottom: 8px;
            font-size: 15px;
        }

        .historial-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }

        .btn-clear {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }

        .btn-start {
            background: linear-gradient(135deg, #00ccff, #0088ff);
            color: #fff;
            grid-column: 1 / -1;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: rgba(255, 68, 68, 0.2);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin: 8px 0;
            text-align: center;
            font-size: 12px;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 18px;
            }
            
            .total-display h2 {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üíµ Detector de Billetes Pro</h1>
            <div class="status" id="status">Presiona iniciar</div>
        </div>

        <div class="camera-container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
            <div class="camera-controls">
                <button class="btn-switch-camera" id="btnSwitchCamera" onclick="cambiarCamara()" style="display:none;">
                    üîÑ
                </button>
            </div>
        </div>

        <div class="total-display">
            <h2 id="total">$0</h2>
        </div>

        <div class="controls-panel">
            <div class="control-row">
                <label>Confianza:</label>
                <input type="range" id="confSlider" min="20" max="90" value="50" oninput="actualizarConf(this.value)">
                <span id="confValue">50%</span>
            </div>
            <div class="control-row">
                <label>Velocidad:</label>
                <input type="range" id="speedSlider" min="1" max="5" value="2" oninput="actualizarVelocidad(this.value)">
                <span id="speedValue">Media</span>
            </div>
        </div>

        <div class="desglose" id="desglose">
            <p style="text-align: center; color: #888; font-size: 13px;">Sin detecciones</p>
        </div>

        <div class="historial">
            <h3>üìã Historial</h3>
            <div id="historial-list"></div>
        </div>

        <div class="buttons">
            <button class="btn-start" id="btnStart" onclick="iniciarCamara()">
                üé• INICIAR C√ÅMARA
            </button>
            <button class="btn-start" style="background: linear-gradient(135deg, #ff9500, #ff5e00);" onclick="probarConImagen()">
                üñºÔ∏è PROBAR CON IMAGEN
            </button>
            <button class="btn-save" onclick="guardarConteo()">üíæ GUARDAR</button>
            <button class="btn-clear" onclick="limpiarTodo()">üóëÔ∏è LIMPIAR</button>
        </div>

        <input type="file" id="imageInput" accept="image/*" style="display:none;" onchange="procesarImagen(this)">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <script>
        const CLASS_NAMES = ['100', '1000', '10000', '100000', '200', '2000', '20000', '50', '500', '5000', '50000'];
        
        const VALORES = {
            "100": 100, "1000": 1000, "10000": 10000, "100000": 100000,
            "200": 200, "2000": 2000, "20000": 20000,
            "50": 50, "500": 500, "5000": 5000, "50000": 50000
        };

        let CONF_THRESHOLD = 0.5;
        const IOU_THRESHOLD = 0.5;
        const INPUT_SIZE = 640;

        let video, canvas, ctx;
        let stream = null;
        let deteccionesActuales = {};
        let totalActual = 0;
        let historial = [];
        let deteccionActiva = false;
        let session = null;
        let camarasDisponibles = [];
        let camaraActualIndex = 0;
        let deteccionInterval = 2500; // Ajustado para m√≥viles
        let procesando = false;
        let animationFrameId = null;

        // üöÄ OPTIMIZACI√ìN M√ìVIL: Detectar dispositivo y ajustar configuraci√≥n
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = isMobile && (navigator.hardwareConcurrency <= 4 || navigator.deviceMemory <= 2);

        // Configuraci√≥n adaptativa seg√∫n dispositivo
        const CONFIG = {
            videoWidth: isMobile ? 640 : 1280,
            videoHeight: isMobile ? 480 : 720,
            canvasScale: isLowEnd ? 0.5 : 1, // Reducir calidad canvas en dispositivos bajos
            useOffscreen: !isMobile, // OffscreenCanvas solo en desktop
            detectionInterval: isLowEnd ? 3000 : (isMobile ? 2000 : 1500),
            maxDetectionsToRender: isMobile ? 20 : 50 // Limitar dibujo en m√≥viles
        };

        console.log('üì± Dispositivo:', isMobile ? 'M√≥vil' : 'Desktop', '| Bajo rendimiento:', isLowEnd);

        function actualizarConf(value) {
            CONF_THRESHOLD = value / 100;
            document.getElementById('confValue').textContent = value + '%';
        }

        function actualizarVelocidad(value) {
            const velocidades = {
                '1': { texto: 'Lenta', ms: 4000 },
                '2': { texto: 'Media', ms: 2500 },
                '3': { texto: 'R√°pida', ms: 1500 },
                '4': { texto: 'Turbo', ms: 1000 },
                '5': { texto: 'Ultra', ms: 500 }
            };
            const vel = velocidades[value];
            deteccionInterval = vel.ms;
            document.getElementById('speedValue').textContent = vel.texto;
        }

        function cargarHistorial() {
            try {
                const saved = localStorage.getItem('historial_billetes');
                if (saved) {
                    historial = JSON.parse(saved);
                    actualizarHistorialUI();
                }
            } catch (e) {
                console.warn('Error cargando historial:', e);
            }
        }

        window.onload = async function() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d', {
                alpha: false,
                desynchronized: true, // üöÄ Mejora rendimiento
                willReadFrequently: false
            });
            
            cargarHistorial();
            
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            let navegadorProblematico = false;
            let mensajeNavegador = '';
            
            if (/FBAN|FBAV|Instagram|Line|Snapchat|Twitter|WhatsApp/i.test(userAgent)) {
                navegadorProblematico = true;
                mensajeNavegador = '‚ö†Ô∏è Navegador in-app detectado. Abre en Chrome/Safari';
            }
            
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
            
            if (isIOS && !isSafari) {
                navegadorProblematico = true;
                mensajeNavegador = '‚ö†Ô∏è En iOS usa Safari';
            }
            
            if (navegadorProblematico) {
                document.getElementById('status').innerHTML = 
                    `<div class="error">${mensajeNavegador}<br><small>üí° Usa "PROBAR CON IMAGEN"</small></div>`;
            }
            
            try {
                document.getElementById('status').textContent = 'Cargando modelo...';
                
                // üöÄ OPTIMIZACI√ìN: Configurar WebGL para mejor rendimiento
                ort.env.wasm.numThreads = isMobile ? 2 : 4;
                ort.env.wasm.simd = true;
                
                session = await ort.InferenceSession.create('models/best.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });
                
                console.log('‚úÖ Modelo cargado | Threads:', ort.env.wasm.numThreads);
                
                if (!navegadorProblematico) {
                    document.getElementById('status').textContent = '‚úÖ Listo';
                }
            } catch (error) {
                console.error('‚ùå Error modelo:', error);
                document.getElementById('status').innerHTML = 
                    '<div class="error">‚ö†Ô∏è Modelo no encontrado</div>';
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                camarasDisponibles = devices.filter(d => d.kind === 'videoinput');
                
                if (camarasDisponibles.length > 1) {
                    document.getElementById('btnSwitchCamera').style.display = 'block';
                }
            } catch (error) {
                console.error('Error listando c√°maras:', error);
            }
        };

        async function iniciarCamara() {
            if (!session) {
                alert('‚ö†Ô∏è Modelo no cargado');
                return;
            }

            const esHTTPS = window.location.protocol === 'https:';
            const esLocalhost = window.location.hostname === 'localhost' || 
                               window.location.hostname === '127.0.0.1';
            
            if (!esHTTPS && !esLocalhost) {
                document.getElementById('status').innerHTML = 
                    '<div class="error">‚ö†Ô∏è HTTPS requerido. Usa "PROBAR CON IMAGEN"</div>';
                return;
            }

            try {
                document.getElementById('status').textContent = '‚è≥ Solicitando c√°mara...';
                document.getElementById('btnStart').disabled = true;

                if (!navigator.mediaDevices?.getUserMedia) {
                    throw new Error('Navegador no soporta c√°mara');
                }

                // üöÄ CONSTRAINTS OPTIMIZADAS PARA M√ìVILES
                let constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: CONFIG.videoWidth },
                        height: { ideal: CONFIG.videoHeight },
                        frameRate: { ideal: isMobile ? 15 : 30 } // üöÄ Reducir FPS en m√≥viles
                    }
                };

                if (camarasDisponibles.length > 0 && !isMobile) {
                    const camara = camarasDisponibles[camaraActualIndex];
                    constraints.video.deviceId = { ideal: camara.deviceId };
                }

                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (constraintError) {
                    console.warn('‚ö†Ô∏è Intentando constraints b√°sicas...');
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                }
                
                video.srcObject = stream;
                
                // üî• CR√çTICO: Forzar reproducci√≥n del video
                await video.play().catch(err => console.warn('Play error:', err));
                
                video.onloadedmetadata = function() {
                    // üöÄ OPTIMIZACI√ìN: Reducir canvas en dispositivos low-end
                    canvas.width = video.videoWidth * CONFIG.canvasScale;
                    canvas.height = video.videoHeight * CONFIG.canvasScale;
                    
                    console.log('üìπ Video size:', video.videoWidth, 'x', video.videoHeight);
                    console.log('üé® Canvas size:', canvas.width, 'x', canvas.height);
                    
                    console.log('‚úÖ C√°mara:', canvas.width, 'x', canvas.height);
                    
                    document.getElementById('status').textContent = '‚úÖ Detectando';
                    document.getElementById('btnStart').textContent = 'üõë DETENER';
                    document.getElementById('btnStart').onclick = detenerCamara;
                    document.getElementById('btnStart').disabled = false;
                    
                    deteccionActiva = true;
                    detectarConONNX();
                };

            } catch (error) {
                console.error('‚ùå Error c√°mara:', error);
                
                let mensaje = '‚ùå ';
                let sugerencia = '';
                
                if (error.name === 'NotAllowedError') {
                    mensaje += 'Permisos denegados';
                    sugerencia = 'üí° Permite acceso en configuraci√≥n';
                } else if (error.name === 'NotFoundError') {
                    mensaje += 'C√°mara no encontrada';
                    sugerencia = 'üí° Usa "PROBAR CON IMAGEN"';
                } else if (error.name === 'NotReadableError') {
                    mensaje += 'C√°mara ocupada';
                    sugerencia = 'üí° Cierra otras apps';
                } else {
                    mensaje += error.message;
                    sugerencia = 'üí° Usa "PROBAR CON IMAGEN"';
                }
                
                document.getElementById('status').innerHTML = 
                    `<div class="error">${mensaje}<br><small>${sugerencia}</small></div>`;
                document.getElementById('btnStart').disabled = false;
            }
        }

        async function cambiarCamara() {
            if (camarasDisponibles.length <= 1) return;
            camaraActualIndex = (camaraActualIndex + 1) % camarasDisponibles.length;
            if (stream) {
                detenerCamara();
                setTimeout(() => iniciarCamara(), 300);
            }
        }

        function detenerCamara() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                deteccionActiva = false;
                procesando = false;
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                document.getElementById('status').textContent = '‚è∏Ô∏è Detenido';
                document.getElementById('btnStart').textContent = 'üé• INICIAR C√ÅMARA';
                document.getElementById('btnStart').onclick = iniciarCamara;
            }
        }

        async function detectarConONNX() {
            if (!deteccionActiva || !session || procesando) {
                if (deteccionActiva) {
                    setTimeout(detectarConONNX, deteccionInterval);
                }
                return;
            }

            procesando = true;
            document.getElementById('status').textContent = 'üîÑ Analizando...';

            try {
                const startTime = performance.now();
                
                const input = preprocesarImagen();
                const feeds = {};
                feeds[session.inputNames[0]] = input;
                const results = await session.run(feeds);
                
                const output = results[session.outputNames[0]];
                const outputData = output.data;
                
                const detecciones = postprocesarResultados(outputData, canvas.width, canvas.height);
                const deteccionesFiltradas = nonMaxSuppression(detecciones, IOU_THRESHOLD);
                
                deteccionesActuales = {};
                for (const det of deteccionesFiltradas) {
                    deteccionesActuales[det.class] = (deteccionesActuales[det.class] || 0) + 1;
                }
                
                actualizarDisplay();
                
                // üöÄ OPTIMIZACI√ìN: Usar requestAnimationFrame para dibujo suave
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(() => {
                    dibujarDetecciones(deteccionesFiltradas);
                });
                
                const endTime = performance.now();
                const processingTime = (endTime - startTime).toFixed(0);
                
                document.getElementById('status').textContent = 
                    `‚úÖ Detectando (${processingTime}ms)`;
                
            } catch (error) {
                console.error('Error detecci√≥n:', error);
                document.getElementById('status').textContent = '‚ö†Ô∏è Error';
            }

            procesando = false;
            setTimeout(detectarConONNX, deteccionInterval);
        }

        // üöÄ OPTIMIZACI√ìN: Preprocesamiento m√°s eficiente
        function preprocesarImagen() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = INPUT_SIZE;
            tempCanvas.height = INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d', { 
                alpha: false,
                willReadFrequently: true
            });
            
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'low';
            
            tempCtx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
            const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            const { data } = imageData;
            
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            const pixelCount = INPUT_SIZE * INPUT_SIZE;
            
            // üöÄ Loop optimizado con menos operaciones
            for (let i = 0; i < pixelCount; i++) {
                const idx = i << 2; // i * 4 m√°s r√°pido
                input[i] = data[idx] * 0.00392156862745098; // 1/255
                input[pixelCount + i] = data[idx + 1] * 0.00392156862745098;
                input[pixelCount * 2 + i] = data[idx + 2] * 0.00392156862745098;
            }
            
            return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
        }

        function postprocesarResultados(outputData, imgWidth, imgHeight) {
            const detecciones = [];
            const numClases = CLASS_NAMES.length;
            const totalElements = outputData.length;
            const numPredictions = Math.floor(totalElements / (4 + numClases));
            
            const scaleX = imgWidth / INPUT_SIZE;
            const scaleY = imgHeight / INPUT_SIZE;
            
            for (let i = 0; i < numPredictions; i++) {
                const xCenter = outputData[i];
                const yCenter = outputData[numPredictions + i];
                const width = outputData[numPredictions * 2 + i];
                const height = outputData[numPredictions * 3 + i];
                
                let maxScore = 0;
                let maxClassId = 0;
                
                for (let c = 0; c < numClases; c++) {
                    const scoreIndex = numPredictions * (4 + c) + i;
                    const score = outputData[scoreIndex];
                    
                    if (score > maxScore) {
                        maxScore = score;
                        maxClassId = c;
                    }
                }
                
                if (maxScore > CONF_THRESHOLD) {
                    const x1 = Math.max(0, (xCenter - width / 2) * scaleX);
                    const y1 = Math.max(0, (yCenter - height / 2) * scaleY);
                    const x2 = Math.min(imgWidth, (xCenter + width / 2) * scaleX);
                    const y2 = Math.min(imgHeight, (yCenter + height / 2) * scaleY);
                    
                    detecciones.push({
                        class: CLASS_NAMES[maxClassId],
                        conf: maxScore,
                        bbox: [x1, y1, x2, y2]
                    });
                }
            }
            
            return detecciones;
        }

        function nonMaxSuppression(detecciones, iouThreshold) {
            detecciones.sort((a, b) => b.conf - a.conf);
            const resultado = [];
            const suppressed = new Array(detecciones.length).fill(false);
            
            for (let i = 0; i < detecciones.length; i++) {
                if (suppressed[i]) continue;
                resultado.push(detecciones[i]);
                
                for (let j = i + 1; j < detecciones.length; j++) {
                    if (suppressed[j]) continue;
                    if (detecciones[i].class === detecciones[j].class) {
                        const iou = calcularIoU(detecciones[i].bbox, detecciones[j].bbox);
                        if (iou > iouThreshold) suppressed[j] = true;
                    }
                }
            }
            
            return resultado;
        }

        function calcularIoU(bbox1, bbox2) {
            const [x1_1, y1_1, x2_1, y2_1] = bbox1;
            const [x1_2, y1_2, x2_2, y2_2] = bbox2;
            
            const xi1 = Math.max(x1_1, x1_2);
            const yi1 = Math.max(y1_1, y1_2);
            const xi2 = Math.min(x2_1, x2_2);
            const yi2 = Math.min(y2_1, y2_2);
            
            const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
            const bbox1Area = (x2_1 - x1_1) * (y2_1 - y1_1);
            const bbox2Area = (x2_2 - x1_2) * (y2_2 - y1_2);
            const unionArea = bbox1Area + bbox2Area - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        // üöÄ OPTIMIZACI√ìN: Dibujo m√°s eficiente
        function dibujarDetecciones(detecciones) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Limitar detecciones a renderizar en m√≥viles
            const maxRender = Math.min(detecciones.length, CONFIG.maxDetectionsToRender);
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            
            for (let i = 0; i < maxRender; i++) {
                const det = detecciones[i];
                const [x1, y1, x2, y2] = det.bbox;
                
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                
                const label = `${det.class} ${(det.conf * 100).toFixed(0)}%`;
                const textWidth = ctx.measureText(label).width;
                
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(x1, y1 - 20, textWidth + 8, 20);
                ctx.fillStyle = '#000';
                ctx.fillText(label, x1 + 4, y1 - 4);
            }
        }

        function actualizarDisplay() {
            totalActual = 0;
            for (let [billete, cantidad] of Object.entries(deteccionesActuales)) {
                totalActual += VALORES[billete] * cantidad;
            }

            document.getElementById('total').textContent = `${totalActual.toLocaleString()}`;

            const desgloseDiv = document.getElementById('desglose');
            if (Object.keys(deteccionesActuales).length === 0) {
                desgloseDiv.innerHTML = '<p style="text-align:center;color:#888;font-size:13px;">Sin detecciones</p>';
            } else {
                let html = '';
                for (let [billete, cantidad] of Object.entries(deteccionesActuales)) {
                    const subtotal = VALORES[billete] * cantidad;
                    html += `
                        <div class="desglose-item">
                            <span>${cantidad}x ${billete}</span>
                            <span style="color:#00ff88;font-weight:bold;">${subtotal.toLocaleString()}</span>
                        </div>`;
                }
                desgloseDiv.innerHTML = html;
            }
        }

        function guardarConteo() {
            if (totalActual === 0) {
                alert('‚ö†Ô∏è No hay nada que guardar');
                return;
            }

            const registro = {
                timestamp: new Date().toLocaleString(),
                total: totalActual,
                desglose: {...deteccionesActuales}
            };

            historial.unshift(registro);
            if (historial.length > 50) historial = historial.slice(0, 50);
            
            try {
                localStorage.setItem('historial_billetes', JSON.stringify(historial));
                actualizarHistorialUI();
                
                document.getElementById('status').textContent = '‚úÖ Guardado';
                setTimeout(() => {
                    if (deteccionActiva) document.getElementById('status').textContent = '‚úÖ Detectando';
                }, 1500);
            } catch (e) {
                console.error('Error guardando:', e);
                alert('‚ö†Ô∏è Error al guardar');
            }
        }

        function actualizarHistorialUI() {
            const list = document.getElementById('historial-list');
            if (historial.length === 0) {
                list.innerHTML = '<p style="text-align:center;color:#888;font-size:12px;">Sin registros</p>';
                return;
            }

            let html = '';
            for (let reg of historial.slice(0, 8)) {
                const desglose = Object.entries(reg.desglose).map(([b, c]) => `${c}x${b}`).join(', ');
                html += `
                    <div class="historial-item">
                        <strong>${reg.total.toLocaleString()}</strong><br>
                        <small>${desglose}</small><br>
                        <small style="color:#888;">${reg.timestamp}</small>
                    </div>`;
            }
            list.innerHTML = html;
        }

        function limpiarTodo() {
            if (confirm('¬øLimpiar historial?')) {
                deteccionesActuales = {};
                totalActual = 0;
                historial = [];
                localStorage.removeItem('historial_billetes');
                actualizarDisplay();
                actualizarHistorialUI();
                document.getElementById('status').textContent = 'üóëÔ∏è Limpiado';
            }
        }

        function probarConImagen() {
            if (!session) {
                alert('‚ö†Ô∏è Modelo no cargado');
                return;
            }
            document.getElementById('imageInput').click();
        }

        async function procesarImagen(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            console.log('üì∏ Procesando imagen:', file.name);
            
            const img = new Image();
            img.onload = async function() {
                if (stream) detenerCamara();
                
                canvas.width = img.width * CONFIG.canvasScale;
                canvas.height = img.height * CONFIG.canvasScale;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                try {
                    document.getElementById('status').textContent = 'üîç Analizando...';
                    
                    const input = preprocesarImagenStatic(img);
                    const feeds = {};
                    feeds[session.inputNames[0]] = input;
                    
                    const results = await session.run(feeds);
                    const output = results[session.outputNames[0]];
                    const outputData = output.data;
                    
                    const detecciones = postprocesarResultados(outputData, canvas.width, canvas.height);
                    const deteccionesFiltradas = nonMaxSuppression(detecciones, IOU_THRESHOLD);
                    
                    deteccionesActuales = {};
                    for (const det of deteccionesFiltradas) {
                        deteccionesActuales[det.class] = (deteccionesActuales[det.class] || 0) + 1;
                    }
                    
                    actualizarDisplay();
                    dibujarDetecciones(deteccionesFiltradas);
                    
                    document.getElementById('status').textContent = 
                        deteccionesFiltradas.length > 0 ? 
                        `‚úÖ ${deteccionesFiltradas.length} billetes detectados` : 
                        '‚ö†Ô∏è No se detectaron billetes';
                    
                } catch (error) {
                    console.error('‚ùå Error procesando imagen:', error);
                    document.getElementById('status').innerHTML = 
                        '<div class="error">‚ùå Error al procesar</div>';
                }
            };
            
            img.src = URL.createObjectURL(file);
        }

        function preprocesarImagenStatic(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = INPUT_SIZE;
            tempCanvas.height = INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d', { alpha: false });
            
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'low';
            tempCtx.drawImage(img, 0, 0, INPUT_SIZE, INPUT_SIZE);
            
            const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            const { data } = imageData;
            
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            const pixelCount = INPUT_SIZE * INPUT_SIZE;
            
            for (let i = 0; i < pixelCount; i++) {
                const idx = i << 2;
                input[i] = data[idx] * 0.00392156862745098;
                input[pixelCount + i] = data[idx + 1] * 0.00392156862745098;
                input[pixelCount * 2 + i] = data[idx + 2] * 0.00392156862745098;
            }
            
            return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
        }

        window.onbeforeunload = function() {
            if (stream) stream.getTracks().forEach(t => t.stop());
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        };
    </script>
</body>
</html>